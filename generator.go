//+build ignore

package main

import (
	"bufio"
	"bytes"
	"fmt"
	"go/format"
	"io"
	"log"
	"net/http"
	"net/url"
	"os"
	"strings"
	"text/template"
)

type code struct {
	Name  string
	Value string
}

const codesTemplate = `
package input

// Code generated by go generate; DO NOT EDIT.

func evCode(ev EVCode, c uint16) Coder {
	switch ev {
{{range evCode .}}
  case {{.EV}}:
		return {{.CodeType}}(c){{end}}
	}
	return Code(c)
}

{{range $key, $slice := .}}
{{with $keycode := printf "%sCode" $key}}

type {{$keycode}} Code

func (c {{$keycode}}) Code() Code {
	return Code(c)
}

func (c {{$keycode}}) String() string {
	m:=map[{{$keycode}}]string{ {{range removeDuplicates $slice}}{{.Value}}: "{{.Name}}",{{end}} }
	return m[c]
}

// {{$key}}
const (
{{range $slice}} {{.Name}} {{$keycode}} = {{println .Value}} {{end}}
)
{{end}}
{{end}}
`

func getFromFile(fn string) (io.ReadCloser, error) {
	log.Printf("opening file: %v\n", fn)
	return os.Open(fn)
}

// isValidUrl tests a string to determine if it is a well-structured url or not.
func isValidUrl(testURL string) bool {
	_, err := url.ParseRequestURI(testURL)
	if err != nil {
		return false
	}

	u, err := url.Parse(testURL)
	if err != nil || u.Scheme == "" || u.Host == "" {
		return false
	}

	return true
}

func getFromURL(url string) (io.ReadCloser, error) {
	log.Printf("opening url: %v\n", url)
	resp, err := http.Get(url)

	return resp.Body, err
}

func in(v code, cs []code) bool {
	for _, c := range cs {
		if v.Value == c.Value || v.Value == c.Name {
			return true
		}
	}
	return false
}

func removeDuplicates(cs []code) []code {
	pcs := []code{}
	seen := []code{}

	for _, c := range cs {
		if !in(c, seen) {
			pcs = append(pcs, c)
		}
		seen = append(pcs, c)
	}

	return pcs
}

type evCodeMap struct {
	EV       string
	CodeType string
}

func evCode(cs map[string][]code) []evCodeMap {
	codes := []evCodeMap{}
	for _, c := range cs["EV"] {
		cn := c.Name
		ce := strings.SplitN(c.Name, "_", 2)[1]

		if _, ok := cs[ce]; ok {
			codes = append(codes, evCodeMap{cn, ce + "Code"})
		}
	}
	return codes
}

func cmd(src, fn string) error {
	// load input file
	load := getFromFile
	if isValidUrl(src) {
		load = getFromURL
	}

	file, err := load(src)
	if err != nil {
		return err
	}
	defer file.Close()

	// collect the constants
	consts := make(map[string][]code)
	scanner := bufio.NewScanner(file)
	for scanner.Scan() {
		line := scanner.Text()
		fs := strings.Fields(line)
		if len(fs) >= 3 && fs[0] == "#define" {
			ss := strings.SplitN(fs[1], "_", 2)
			prefix, name, value := ss[0], fs[1], fs[2]
			if value[0] == '(' && value[len(value)-1] != ')' {
				for i := 3; i < len(fs); i++ {
					value += fs[i]
					if value[len(value)-1] == ')' {
						break
					}
				}
			}
			c := code{name, value}
			consts[prefix] = append(consts[prefix], c)
		}
	}
	if err := scanner.Err(); err != nil {
		return err
	}

	funcMap := template.FuncMap{
		"removeDuplicates": removeDuplicates,
		"evCode":           evCode,
	}

	// put the constants into the output template
	t, err := template.New("codes").Funcs(funcMap).Parse(codesTemplate)
	if err != nil {
		return err
	}
	bs := &bytes.Buffer{}
	err = t.Execute(bs, consts)
	if err != nil {
		return err
	}

	// format the template
	fbs, err := format.Source(bs.Bytes())
	if err != nil {
		return err
	}

	// save the formatted template to file
	of, err := os.Create(fn)
	if err != nil {
		return err
	}
	defer of.Close()
	of.Write(fbs)
	return nil
}

func main() {
	if len(os.Args) != 3 {
		fmt.Fprintf(os.Stderr, "usage: %s <source> <filename>\n", os.Args[0])
		os.Exit(1)
	}

	if err := cmd(os.Args[1], os.Args[2]); err != nil {
		log.Fatalf("could not generate file: %v", err)
	}
}
